#include <iostream>

using namespace std;

/*
模板声明：template <typename T>
这是 C++ 模板的语法，表明接下来的类是一个泛型类
typename T 声明了一个类型参数 T，允许这个类处理任意数据类型
使用时可以用具体类型（如Iterator<int>、Iterator<std::string>）实例化
*/
template <typename T>

/*
类定义：class Iterator
定义了一个名为Iterator的类，作为所有具体迭代器的基类
*/
class Iterator
{
public:

    /*
    虚析构函数：virtual ~Iterator() = default;
    virtual 关键字表明这是一个虚函数，允许派生类重写
    ~Iterator() 是析构函数，负责对象销毁时的资源清理
    = default 表示使用编译器生成的默认实现
    在接口类中定义虚析构函数是良好实践，确保删除派生类对象时能正确调用析构函数
    */
    virtual ~Iterator() = default;

    /*
    纯虚函数：
    virtual T *first() = 0;
    返回值类型为T*（指向模板类型 T 的指针）
    = 0 表明这是纯虚函数，没有具体实现，必须在派生类中重写
    功能上通常返回聚合中的第一个元素
    */
    virtual T *first() = 0;

    /*
    纯虚函数：
    virtual T *next() = 0;
    返回下一个元素的指针
    也是纯虚函数，需要派生类实现具体的迭代逻辑
    */
    virtual T *next() = 0;

    /*
    纯虚函数：
    virtual T *curr() = 0;
    返回当前元素的指针
    纯虚函数，由派生类实现
    */
    virtual T *curr() = 0;

    /*
    纯虚函数：
    virtual bool isDone() = 0;
    返回值为bool类型，指示迭代是否完成
    纯虚函数，当迭代到末尾时通常返回true
    */
    virtual bool isDone() = 0;
};
/*
从语法特性来看，这个类是一个抽象基类（包含纯虚函数的类），它定义了迭代器的接口规范，但不提供具体实现。
这种设计强制所有派生类必须实现这些方法，保证了迭代器接口的一致性。
模板的使用使得这个迭代器接口可以适用于任何数据类型，无需为每种类型单独定义迭代器接口，体现了 C++ 的泛型编程思想。
*/


/*
在C++中，虚函数、纯虚函数、虚析构和纯虚析构是面向对象编程中实现多态的重要概念，它们的区别如下：


### **1. 虚函数（Virtual Function） vs 纯虚函数（Pure Virtual Function）**

#### **虚函数（Virtual Function）**
- **定义**：在基类中使用`virtual`关键字声明，并提供默认实现的函数。
- **语法**：
  ```cpp
  class Base {
  public:
      virtual void func() {  // 虚函数，有默认实现
          cout << "Base::func()" << endl;
      }
  };
  ```
- **特点**：
  - 派生类可以**重写**（override）该函数，也可以不重写（使用基类的默认实现）。
  - 基类本身可以被实例化（创建对象）。
  - 用于实现"接口继承"，同时提供默认行为。


#### **纯虚函数（Pure Virtual Function）**
- **定义**：在基类中使用`virtual`关键字声明，且没有默认实现（用`= 0`标记）的函数。
- **语法**：
  ```cpp
  class Base {
  public:
      virtual void func() = 0;  // 纯虚函数，无实现
  };
  ```
- **特点**：
  - 派生类**必须**重写该函数（否则派生类也会成为抽象类，无法实例化）。
  - 包含纯虚函数的类称为**抽象类**，不能被实例化（无法创建对象）。
  - 仅用于定义接口规范，强制派生类实现具体逻辑。


### **2. 虚析构（Virtual Destructor） vs 纯虚析构（Pure Virtual Destructor）**

析构函数的特殊性在于：当通过基类指针删除派生类对象时，需要确保派生类的析构函数被正确调用，否则会导致资源泄漏。因此需要将析构函数声明为`virtual`。

#### **虚析构（Virtual Destructor）**
- **定义**：使用`virtual`关键字声明，且有具体实现的析构函数。
- **语法**：
  ```cpp
  class Base {
  public:
      virtual ~Base() {  // 虚析构，有实现
          cout << "Base::~Base()" << endl;
      }
  };
  ```
- **特点**：
  - 基类可以被实例化。
  - 派生类析构函数会自动调用基类析构函数，保证析构顺序正确。


#### **纯虚析构（Pure Virtual Destructor）**
- **定义**：使用`virtual`关键字声明，且用`= 0`标记的析构函数，但**必须提供实现**（这是C++的特殊规定）。
- **语法**：
  ```cpp
  class Base {
  public:
      virtual ~Base() = 0;  // 纯虚析构，声明
  };

  // 必须在类外提供实现（否则链接错误）
  Base::~Base() {
      cout << "Base::~Base()" << endl;
  }
  ```
- **特点**：
  - 包含纯虚析构的类是**抽象类**，不能被实例化。
  - 派生类必须自己实现析构函数（但会自动调用基类的纯虚析构实现）。
  - 用于既要强制派生类实现析构逻辑，又要使基类成为抽象类的场景。


### **核心区别总结**
| 类型         | 关键标识       | 是否需要实现 | 基类是否可实例化 | 派生类要求                     |
|--------------|----------------|--------------|------------------|--------------------------------|
| 虚函数       | `virtual`      | 是           | 是               | 可重写，也可使用基类实现       |
| 纯虚函数     | `virtual ... = 0` | 否           | 否（抽象类）     | 必须重写                       |
| 虚析构       | `virtual ~类名()` | 是           | 是               | 可自定义析构，自动调用基类析构 |
| 纯虚析构     | `virtual ~类名() = 0` | 是（类外）   | 否（抽象类）     | 必须自定义析构，自动调用基类实现 |


### **注意点**
- 纯虚析构必须提供实现，因为析构函数的调用链（派生类→基类）必须完整。
- 只要类中包含纯虚函数（包括纯虚析构），该类就是抽象类，无法实例化。
- 虚函数和虚析构的核心作用是实现多态下的正确函数调用（动态绑定）。
*/
int main()
{
    cout << "Hello C++!" << endl;
}